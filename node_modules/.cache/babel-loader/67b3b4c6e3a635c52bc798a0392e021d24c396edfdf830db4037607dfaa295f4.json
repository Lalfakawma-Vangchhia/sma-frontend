{"ast":null,"code":"// WebSocket Notification Service for Real-time Updates\nclass NotificationService {\n  constructor() {\n    this.ws = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000; // Start with 1 second\n    this.listeners = new Map();\n    this.isConnecting = false;\n    this.shouldReconnect = true;\n  }\n\n  // Connect to WebSocket with authentication\n  connect(token) {\n    if (this.isConnecting || this.ws && this.ws.readyState === WebSocket.OPEN) {\n      console.log('🔌 WebSocket already connected or connecting');\n      return;\n    }\n    if (!token) {\n      console.error('❌ No authentication token provided for WebSocket connection');\n      return;\n    }\n\n    // Store token for reconnection attempts\n    this.token = token;\n    this.shouldReconnect = true;\n    this.isConnecting = true;\n    try {\n      // Determine WebSocket protocol based on current page protocol\n      const isHttps = window.location.protocol === 'https:';\n      const wsProtocol = isHttps ? 'wss:' : 'ws:';\n      const wsUrl = `${wsProtocol}//localhost:8000/ws/notifications?token=${encodeURIComponent(token)}`;\n      console.log('🔌 Connecting to WebSocket:', wsUrl);\n      this.ws = new WebSocket(wsUrl);\n      this.ws.onopen = () => {\n        console.log('✅ WebSocket connected successfully');\n        this.isConnecting = false;\n        this.reconnectAttempts = 0;\n        this.reconnectDelay = 1000;\n\n        // Notify listeners about connection\n        this.notifyListeners('connection', {\n          status: 'connected'\n        });\n      };\n      this.ws.onmessage = event => {\n        try {\n          const notification = JSON.parse(event.data);\n          console.log('📨 Received notification:', notification);\n\n          // Handle different notification types\n          this.handleNotification(notification);\n        } catch (error) {\n          console.error('❌ Error parsing notification:', error);\n        }\n      };\n      this.ws.onclose = event => {\n        console.log('🔌 WebSocket connection closed:', event.code, event.reason);\n        this.isConnecting = false;\n\n        // Notify listeners about disconnection\n        this.notifyListeners('connection', {\n          status: 'disconnected',\n          code: event.code,\n          reason: event.reason\n        });\n\n        // Always attempt to reconnect unless explicitly disconnected by user\n        if (this.shouldReconnect) {\n          console.log('🔄 WebSocket closed, attempting to reconnect...');\n          this.attemptReconnect();\n        }\n      };\n      this.ws.onerror = error => {\n        console.error('❌ WebSocket error:', error);\n        this.isConnecting = false;\n\n        // Notify listeners about error\n        this.notifyListeners('connection', {\n          status: 'error',\n          error\n        });\n      };\n    } catch (error) {\n      console.error('❌ Error creating WebSocket connection:', error);\n      this.isConnecting = false;\n    }\n  }\n\n  // Handle different types of notifications\n  handleNotification(notification) {\n    const {\n      type\n    } = notification;\n    switch (type) {\n      case 'scheduled_post_reminder':\n        this.handleScheduledPostReminder(notification);\n        break;\n      case 'scheduled_post_status':\n        this.handleScheduledPostStatus(notification);\n        break;\n      case 'test_notification':\n        this.handleTestNotification(notification);\n        break;\n      default:\n        console.log('📨 Unknown notification type:', type);\n        this.notifyListeners('notification', notification);\n    }\n  }\n\n  // Handle scheduled post reminder notifications\n  handleScheduledPostReminder(notification) {\n    console.log('⏰ Scheduled post reminder:', notification);\n\n    // Show browser notification if permission granted\n    this.showBrowserNotification('Scheduled Post Reminder', `Your post \"${notification.prompt}\" will be published in ${notification.minutes_until} minutes`, 'reminder');\n\n    // Notify listeners\n    this.notifyListeners('scheduled_post_reminder', notification);\n  }\n\n  // Handle scheduled post status notifications\n  handleScheduledPostStatus(notification) {\n    console.log('📱 Scheduled post status:', notification);\n    const isSuccess = notification.status === 'success';\n    const title = isSuccess ? 'Post Published Successfully!' : 'Post Publication Failed';\n    const icon = isSuccess ? 'success' : 'error';\n\n    // Show browser notification\n    this.showBrowserNotification(title, notification.message, icon);\n\n    // Notify listeners\n    this.notifyListeners('scheduled_post_status', notification);\n  }\n\n  // Handle test notifications\n  handleTestNotification(notification) {\n    console.log('🧪 Test notification:', notification);\n\n    // Show browser notification\n    this.showBrowserNotification('WebSocket Test', notification.message || 'WebSocket connection is working correctly!', 'info');\n\n    // Notify listeners\n    this.notifyListeners('test_notification', notification);\n  }\n\n  // Show browser notification\n  showBrowserNotification(title, body, type = 'info') {\n    // Check if browser supports notifications\n    if (!('Notification' in window)) {\n      console.log('📱 Browser does not support notifications');\n      return;\n    }\n\n    // Check notification permission\n    if (Notification.permission === 'granted') {\n      const options = {\n        body,\n        icon: this.getNotificationIcon(type),\n        badge: '/favicon.ico',\n        tag: `scheduled-post-${type}`,\n        requireInteraction: type === 'error',\n        // Keep error notifications visible\n        silent: false\n      };\n      const notification = new Notification(title, options);\n\n      // Auto-close after 5 seconds for non-error notifications\n      if (type !== 'error') {\n        setTimeout(() => notification.close(), 5000);\n      }\n      notification.onclick = () => {\n        window.focus();\n        notification.close();\n      };\n    } else if (Notification.permission !== 'denied') {\n      // Request permission\n      Notification.requestPermission().then(permission => {\n        if (permission === 'granted') {\n          this.showBrowserNotification(title, body, type);\n        }\n      });\n    }\n  }\n\n  // Get notification icon based on type\n  getNotificationIcon(type) {\n    const icons = {\n      success: '✅',\n      error: '❌',\n      reminder: '⏰',\n      info: 'ℹ️'\n    };\n    return icons[type] || icons.info;\n  }\n\n  // Attempt to reconnect with exponential backoff\n  attemptReconnect(token = null) {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('❌ Max reconnection attempts reached');\n      this.notifyListeners('connection', {\n        status: 'failed',\n        reason: 'Max reconnection attempts reached'\n      });\n      return;\n    }\n\n    // Use stored token if no token provided\n    const reconnectToken = token || this.token;\n    if (!reconnectToken) {\n      console.error('❌ No token available for reconnection');\n      return;\n    }\n    this.reconnectAttempts++;\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    console.log(`🔄 Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n    setTimeout(() => {\n      if (this.shouldReconnect) {\n        this.connect(reconnectToken);\n      }\n    }, delay);\n  }\n\n  // Add event listener\n  addEventListener(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(event, callback) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n  }\n\n  // Notify all listeners for an event\n  notifyListeners(event, data) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`❌ Error in notification listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // Request notification permission\n  async requestNotificationPermission() {\n    if (!('Notification' in window)) {\n      console.log('📱 Browser does not support notifications');\n      return false;\n    }\n    if (Notification.permission === 'granted') {\n      return true;\n    }\n    if (Notification.permission !== 'denied') {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n    return false;\n  }\n\n  // Disconnect WebSocket\n  disconnect() {\n    this.shouldReconnect = false;\n    this.token = null;\n    if (this.ws) {\n      this.ws.close(1000, 'User disconnected');\n      this.ws = null;\n    }\n    console.log('🔌 WebSocket disconnected by user');\n  }\n\n  // Ensure connection is maintained (call this on route changes)\n  ensureConnection() {\n    if (this.token && (!this.ws || this.ws.readyState !== WebSocket.OPEN)) {\n      console.log('🔄 Ensuring WebSocket connection is active');\n      this.connect(this.token);\n    }\n  }\n\n  // Force reconnection\n  forceReconnect() {\n    if (this.token) {\n      console.log('🔄 Force reconnecting WebSocket');\n      this.disconnect();\n      setTimeout(() => {\n        this.shouldReconnect = true;\n        this.connect(this.token);\n      }, 1000);\n    }\n  }\n\n  // Get connection status\n  getConnectionStatus() {\n    if (!this.ws) return 'disconnected';\n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'connected';\n      case WebSocket.CLOSING:\n        return 'closing';\n      case WebSocket.CLOSED:\n        return 'disconnected';\n      default:\n        return 'unknown';\n    }\n  }\n\n  // Check if connected\n  isConnected() {\n    return this.ws && this.ws.readyState === WebSocket.OPEN;\n  }\n}\n\n// Create singleton instance\nconst notificationService = new NotificationService();\nexport default notificationService;","map":{"version":3,"names":["NotificationService","constructor","ws","reconnectAttempts","maxReconnectAttempts","reconnectDelay","listeners","Map","isConnecting","shouldReconnect","connect","token","readyState","WebSocket","OPEN","console","log","error","isHttps","window","location","protocol","wsProtocol","wsUrl","encodeURIComponent","onopen","notifyListeners","status","onmessage","event","notification","JSON","parse","data","handleNotification","onclose","code","reason","attemptReconnect","onerror","type","handleScheduledPostReminder","handleScheduledPostStatus","handleTestNotification","showBrowserNotification","prompt","minutes_until","isSuccess","title","icon","message","body","Notification","permission","options","getNotificationIcon","badge","tag","requireInteraction","silent","setTimeout","close","onclick","focus","requestPermission","then","icons","success","reminder","info","reconnectToken","delay","Math","pow","addEventListener","callback","has","set","Set","get","add","removeEventListener","delete","forEach","requestNotificationPermission","disconnect","ensureConnection","forceReconnect","getConnectionStatus","CONNECTING","CLOSING","CLOSED","isConnected","notificationService"],"sources":["C:/Users/THORSIGNIA/Projects/automation-dash/frontend/src/services/notificationService.js"],"sourcesContent":["// WebSocket Notification Service for Real-time Updates\r\nclass NotificationService {\r\n  constructor() {\r\n    this.ws = null;\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectDelay = 1000; // Start with 1 second\r\n    this.listeners = new Map();\r\n    this.isConnecting = false;\r\n    this.shouldReconnect = true;\r\n  }\r\n\r\n  // Connect to WebSocket with authentication\r\n  connect(token) {\r\n    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {\r\n      console.log('🔌 WebSocket already connected or connecting');\r\n      return;\r\n    }\r\n\r\n    if (!token) {\r\n      console.error('❌ No authentication token provided for WebSocket connection');\r\n      return;\r\n    }\r\n\r\n    // Store token for reconnection attempts\r\n    this.token = token;\r\n    this.shouldReconnect = true;\r\n    this.isConnecting = true;\r\n    \r\n    try {\r\n      // Determine WebSocket protocol based on current page protocol\r\n      const isHttps = window.location.protocol === 'https:';\r\n      const wsProtocol = isHttps ? 'wss:' : 'ws:';\r\n      const wsUrl = `${wsProtocol}//localhost:8000/ws/notifications?token=${encodeURIComponent(token)}`;\r\n      \r\n      console.log('🔌 Connecting to WebSocket:', wsUrl);\r\n      \r\n      this.ws = new WebSocket(wsUrl);\r\n      \r\n      this.ws.onopen = () => {\r\n        console.log('✅ WebSocket connected successfully');\r\n        this.isConnecting = false;\r\n        this.reconnectAttempts = 0;\r\n        this.reconnectDelay = 1000;\r\n        \r\n        // Notify listeners about connection\r\n        this.notifyListeners('connection', { status: 'connected' });\r\n      };\r\n      \r\n      this.ws.onmessage = (event) => {\r\n        try {\r\n          const notification = JSON.parse(event.data);\r\n          console.log('📨 Received notification:', notification);\r\n          \r\n          // Handle different notification types\r\n          this.handleNotification(notification);\r\n          \r\n        } catch (error) {\r\n          console.error('❌ Error parsing notification:', error);\r\n        }\r\n      };\r\n      \r\n      this.ws.onclose = (event) => {\r\n        console.log('🔌 WebSocket connection closed:', event.code, event.reason);\r\n        this.isConnecting = false;\r\n        \r\n        // Notify listeners about disconnection\r\n        this.notifyListeners('connection', { status: 'disconnected', code: event.code, reason: event.reason });\r\n        \r\n        // Always attempt to reconnect unless explicitly disconnected by user\r\n        if (this.shouldReconnect) {\r\n          console.log('🔄 WebSocket closed, attempting to reconnect...');\r\n          this.attemptReconnect();\r\n        }\r\n      };\r\n      \r\n      this.ws.onerror = (error) => {\r\n        console.error('❌ WebSocket error:', error);\r\n        this.isConnecting = false;\r\n        \r\n        // Notify listeners about error\r\n        this.notifyListeners('connection', { status: 'error', error });\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('❌ Error creating WebSocket connection:', error);\r\n      this.isConnecting = false;\r\n    }\r\n  }\r\n\r\n  // Handle different types of notifications\r\n  handleNotification(notification) {\r\n    const { type } = notification;\r\n    \r\n    switch (type) {\r\n      case 'scheduled_post_reminder':\r\n        this.handleScheduledPostReminder(notification);\r\n        break;\r\n      case 'scheduled_post_status':\r\n        this.handleScheduledPostStatus(notification);\r\n        break;\r\n      case 'test_notification':\r\n        this.handleTestNotification(notification);\r\n        break;\r\n      default:\r\n        console.log('📨 Unknown notification type:', type);\r\n        this.notifyListeners('notification', notification);\r\n    }\r\n  }\r\n\r\n  // Handle scheduled post reminder notifications\r\n  handleScheduledPostReminder(notification) {\r\n    console.log('⏰ Scheduled post reminder:', notification);\r\n    \r\n    // Show browser notification if permission granted\r\n    this.showBrowserNotification(\r\n      'Scheduled Post Reminder',\r\n      `Your post \"${notification.prompt}\" will be published in ${notification.minutes_until} minutes`,\r\n      'reminder'\r\n    );\r\n    \r\n    // Notify listeners\r\n    this.notifyListeners('scheduled_post_reminder', notification);\r\n  }\r\n\r\n  // Handle scheduled post status notifications\r\n  handleScheduledPostStatus(notification) {\r\n    console.log('📱 Scheduled post status:', notification);\r\n    \r\n    const isSuccess = notification.status === 'success';\r\n    const title = isSuccess ? 'Post Published Successfully!' : 'Post Publication Failed';\r\n    const icon = isSuccess ? 'success' : 'error';\r\n    \r\n    // Show browser notification\r\n    this.showBrowserNotification(title, notification.message, icon);\r\n    \r\n    // Notify listeners\r\n    this.notifyListeners('scheduled_post_status', notification);\r\n  }\r\n\r\n  // Handle test notifications\r\n  handleTestNotification(notification) {\r\n    console.log('🧪 Test notification:', notification);\r\n    \r\n    // Show browser notification\r\n    this.showBrowserNotification(\r\n      'WebSocket Test',\r\n      notification.message || 'WebSocket connection is working correctly!',\r\n      'info'\r\n    );\r\n    \r\n    // Notify listeners\r\n    this.notifyListeners('test_notification', notification);\r\n  }\r\n\r\n  // Show browser notification\r\n  showBrowserNotification(title, body, type = 'info') {\r\n    // Check if browser supports notifications\r\n    if (!('Notification' in window)) {\r\n      console.log('📱 Browser does not support notifications');\r\n      return;\r\n    }\r\n\r\n    // Check notification permission\r\n    if (Notification.permission === 'granted') {\r\n      const options = {\r\n        body,\r\n        icon: this.getNotificationIcon(type),\r\n        badge: '/favicon.ico',\r\n        tag: `scheduled-post-${type}`,\r\n        requireInteraction: type === 'error', // Keep error notifications visible\r\n        silent: false\r\n      };\r\n\r\n      const notification = new Notification(title, options);\r\n      \r\n      // Auto-close after 5 seconds for non-error notifications\r\n      if (type !== 'error') {\r\n        setTimeout(() => notification.close(), 5000);\r\n      }\r\n      \r\n      notification.onclick = () => {\r\n        window.focus();\r\n        notification.close();\r\n      };\r\n    } else if (Notification.permission !== 'denied') {\r\n      // Request permission\r\n      Notification.requestPermission().then(permission => {\r\n        if (permission === 'granted') {\r\n          this.showBrowserNotification(title, body, type);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Get notification icon based on type\r\n  getNotificationIcon(type) {\r\n    const icons = {\r\n      success: '✅',\r\n      error: '❌',\r\n      reminder: '⏰',\r\n      info: 'ℹ️'\r\n    };\r\n    return icons[type] || icons.info;\r\n  }\r\n\r\n  // Attempt to reconnect with exponential backoff\r\n  attemptReconnect(token = null) {\r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.error('❌ Max reconnection attempts reached');\r\n      this.notifyListeners('connection', { status: 'failed', reason: 'Max reconnection attempts reached' });\r\n      return;\r\n    }\r\n\r\n    // Use stored token if no token provided\r\n    const reconnectToken = token || this.token;\r\n    if (!reconnectToken) {\r\n      console.error('❌ No token available for reconnection');\r\n      return;\r\n    }\r\n\r\n    this.reconnectAttempts++;\r\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\r\n    \r\n    console.log(`🔄 Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n    \r\n    setTimeout(() => {\r\n      if (this.shouldReconnect) {\r\n        this.connect(reconnectToken);\r\n      }\r\n    }, delay);\r\n  }\r\n\r\n  // Add event listener\r\n  addEventListener(event, callback) {\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, new Set());\r\n    }\r\n    this.listeners.get(event).add(callback);\r\n  }\r\n\r\n  // Remove event listener\r\n  removeEventListener(event, callback) {\r\n    if (this.listeners.has(event)) {\r\n      this.listeners.get(event).delete(callback);\r\n    }\r\n  }\r\n\r\n  // Notify all listeners for an event\r\n  notifyListeners(event, data) {\r\n    if (this.listeners.has(event)) {\r\n      this.listeners.get(event).forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`❌ Error in notification listener for ${event}:`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Request notification permission\r\n  async requestNotificationPermission() {\r\n    if (!('Notification' in window)) {\r\n      console.log('📱 Browser does not support notifications');\r\n      return false;\r\n    }\r\n\r\n    if (Notification.permission === 'granted') {\r\n      return true;\r\n    }\r\n\r\n    if (Notification.permission !== 'denied') {\r\n      const permission = await Notification.requestPermission();\r\n      return permission === 'granted';\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // Disconnect WebSocket\r\n  disconnect() {\r\n    this.shouldReconnect = false;\r\n    this.token = null;\r\n    \r\n    if (this.ws) {\r\n      this.ws.close(1000, 'User disconnected');\r\n      this.ws = null;\r\n    }\r\n    \r\n    console.log('🔌 WebSocket disconnected by user');\r\n  }\r\n\r\n  // Ensure connection is maintained (call this on route changes)\r\n  ensureConnection() {\r\n    if (this.token && (!this.ws || this.ws.readyState !== WebSocket.OPEN)) {\r\n      console.log('🔄 Ensuring WebSocket connection is active');\r\n      this.connect(this.token);\r\n    }\r\n  }\r\n\r\n  // Force reconnection\r\n  forceReconnect() {\r\n    if (this.token) {\r\n      console.log('🔄 Force reconnecting WebSocket');\r\n      this.disconnect();\r\n      setTimeout(() => {\r\n        this.shouldReconnect = true;\r\n        this.connect(this.token);\r\n      }, 1000);\r\n    }\r\n  }\r\n\r\n  // Get connection status\r\n  getConnectionStatus() {\r\n    if (!this.ws) return 'disconnected';\r\n    \r\n    switch (this.ws.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return 'connecting';\r\n      case WebSocket.OPEN:\r\n        return 'connected';\r\n      case WebSocket.CLOSING:\r\n        return 'closing';\r\n      case WebSocket.CLOSED:\r\n        return 'disconnected';\r\n      default:\r\n        return 'unknown';\r\n    }\r\n  }\r\n\r\n  // Check if connected\r\n  isConnected() {\r\n    return this.ws && this.ws.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst notificationService = new NotificationService();\r\n\r\nexport default notificationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}